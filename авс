    .data
prompt_n:      .asciz "Введите размер массива (от 1 до 10): "   # Сообщение для ввода N
prompt_a:      .asciz "Введите элемент массива A: "             # Сообщение для ввода элемента массива A
output_a:      .asciz "Массив A: "                              # Сообщение для вывода массива A
output_b:      .asciz "Массив B: "                              # Сообщение для вывода массива B
newline:       .asciz "\n"                                      # Новая строка
space:         .asciz " "                                       # Пробел
error_msg:     .asciz "Неверный ввод. Введите число от 1 до 10.\n" # Сообщение об ошибке

    .text
    .globl main

# Главная программа
main:
    # Сохраняем регистры t0, t1, t2, t5 на стеке
    addi    sp, sp, -20        # Выделяем место на стеке (20 байт)
    sw      ra, 16(sp)         # Сохраняем регистр ra (адрес возврата)
    sw      t0, 12(sp)         # Сохраняем t0 на стеке
    sw      t1, 8(sp)          # Сохраняем t1 на стеке
    sw      t2, 4(sp)          # Сохраняем t2 на стеке
    sw      t5, 0(sp)          # Сохраняем t5 на стеке

input_n_loop:
    # Вводим размер массива N, результат сохраняется в t0
    jal     input_n            # t0 = N

    # Проверяем корректность размера массива
    blt     t0, 1, error_input # Если N < 1, ошибка
    bgt     t0, 10, error_input # Если N > 10, ошибка

    # Вводим элементы массива A, передаем размер N через t0
    jal     input_array_A      # t0 это N, передается в подпрограмму

    # Выводим массив A, используем размер N из t0
    jal     output_array_A     # t0 это N, передается в подпрограмму

    # Находим индекс последнего положительного элемента, результат сохраняется в t5
    jal     find_last_positive # t0 это N, t5 возвращает индекс

    # Формируем и выводим массив B, передаем N через t0 и индекс через t5
    jal     form_array_B       # t0 это N, t5 это индекс последнего положительного элемента

    j       end_program        # Завершаем программу

# Обработка некорректного ввода N
error_input:
    la      a0, error_msg      # a0 = адрес сообщения об ошибке
    li      a7, 4              # Системный вызов для вывода строки
    ecall
    j       input_n_loop       # Повторный ввод N

# Подпрограмма для ввода N
# Возвращает N в t0
input_n:
    la      a0, prompt_n       # a0 = адрес сообщения для ввода N
    li      a7, 4              # Системный вызов для вывода строки
    ecall

    li      a7, 5              # Системный вызов для чтения целого числа
    ecall
    mv      t0, a0             # t0 = введенное N
    ret

# Подпрограмма для ввода массива A
# Использует t0 как N (размер массива)
input_array_A:
    li      t3, 0              # t3 = индекс массива A (0)
    la      t4, array_A        # t4 = адрес начала массива A
input_loop:
    bge     t3, t0, ret_input  # Если t3 >= N, завершение ввода

    # Выводим запрос на ввод элемента массива A
    la      a0, prompt_a       # a0 = адрес сообщения для ввода элемента
    li      a7, 4              # Системный вызов для вывода строки
    ecall

    # Читаем элемент массива A
    li      a7, 5              # Системный вызов для чтения целого числа
    ecall
    sw      a0, 0(t4)          # Сохраняем введенное значение в массиве A

    # Переходим к следующему элементу
    addi    t4, t4, 4          # t4 = t4 + 4
    addi    t3, t3, 1          # t3 = t3 + 1
    j       input_loop         # Переходим к следующей итерации
ret_input:
    ret

# Подпрограмма для вывода массива A
# Использует t0 как N (размер массива)
output_array_A:
    la      a0, output_a       # a0 = адрес сообщения для вывода массива A
    li      a7, 4
    ecall

    li      t3, 0              # t3 = индекс массива A (0)
    la      t4, array_A        # t4 = адрес начала массива A
output_loop_A:
    bge     t3, t0, ret_output_A  # Если t3 >= N, завершение вывода

    lw      a0, 0(t4)          # Загружаем элемент массива A в a0
    li      a7, 1              # Системный вызов для вывода целого числа
    ecall

    la      a0, space          # Выводим пробел
    li      a7, 4
    ecall

    # Переходим к следующему элементу
    addi    t4, t4, 4
    addi    t3, t3, 1
    j       output_loop_A
ret_output_A:
    la      a0, newline        # Печатаем новую строку
    li      a7, 4
    ecall
    ret

# Подпрограмма для нахождения последнего положительного элемента
# Использует t0 как N (размер массива)
# Возвращает индекс последнего положительного элемента в t5
find_last_positive:
    li      t3, 0              # t3 = индекс массива A (0)
    li      t5, -1             # t5 = индекс последнего положительного элемента (-1)
    la      t4, array_A        # t4 = адрес начала массива A
find_loop:
    bge     t3, t0, ret_find   # Если t3 >= N, завершение поиска

    lw      t6, 0(t4)          # t6 = элемент массива A
    blez    t6, next_find      # Если t6 <= 0, пропустить

    mv      t5, t3             # t5 = t3 (сохраняем индекс)

next_find:
    # Переходим к следующему элементу
    addi    t4, t4, 4
    addi    t3, t3, 1
    j       find_loop
ret_find:
    ret

# Подпрограмма для формирования и вывода массива B
# Использует t0 как N и t5 как индекс последнего положительного элемента
form_array_B:
    la      a0, output_b       # a0 = адрес сообщения для вывода массива B
    li      a7, 4
    ecall

    addi    t5, t5, 1          # t5 = t5 + 1 (начинаем после последнего положительного элемента)
    bge     t5, t0, ret_output_B  # Если t5 >= N, массив B пуст

    la      t4, array_A        # t4 = адрес начала массива A
    slli    t3, t5, 2          # t3 = t5 * 4 (смещение в байтах)
    add     t4, t4, t3         # t4 = адрес элемента массива A после последнего положительного

    la      t6, array_B        # t6 = адрес начала массива B

copy_loop_B:
    bge     t5, t0, ret_output_B  # Если t5 >= N, завершение копирования

    lw      a1, 0(t4)          # Загружаем элемент из массива A
    sw      a1, 0(t6)          # Сохраняем элемент в массиве B

    # Выводим элемент массива B
    lw      a0, 0(t6)
    li      a7, 1
    ecall

    la      a0, space          # Выводим пробел
    li      a7, 4
    ecall

    # Переходим к следующему элементу
    addi    t4, t4, 4
    addi    t6, t6, 4
    addi    t5, t5, 1          # Увеличиваем индекс для A
    j       copy_loop_B
ret_output_B:
    la      a0, newline        # Печатаем новую строку
    li      a7, 4
    ecall
    ret

# Завершение программы
end_program:
    li      a7, 10             # Системный вызов для завершения программы
    ecall

    .data
    .align 2
array_A: .space 40             # Массив A (10 элементов по 4 байта)
array_B: .space 40             # Массив B (10 элементов по 4 байта)
